<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>RexKing6&#39;s Note</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>活成我心中的样子</description>
    <pubDate>Wed, 05 Apr 2017 12:33:23 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>当你在浏览器地址栏输入一个URL后回车，将会发生的事情？</title>
      <link>http://yoursite.com/2017/04/05/%E5%BD%93%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%90%8E%E5%9B%9E%E8%BD%A6%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%9F/</link>
      <guid>http://yoursite.com/2017/04/05/%E5%BD%93%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%90%8E%E5%9B%9E%E8%BD%A6%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%9F/</guid>
      <pubDate>Wed, 05 Apr 2017 00:11:41 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;这是一道很古老的面试题，最近好像常常被拿来做笔试题了，自己想找到一个比较标准详细的答案，然后在知乎上看到了&lt;a href=&quot;http://i
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是一道很古老的面试题，最近好像常常被拿来做笔试题了，自己想找到一个比较标准详细的答案，然后在知乎上看到了<a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/" target="_blank" rel="external">What really happens when you navigate to a URL</a>，应该很权威，然后在CSDN上看到wuhenliushui把它翻译过来了，<a href="http://blog.csdn.net/wuhenliushui/article/details/20038819/" target="_blank" rel="external">当你在浏览器地址栏输入一个URL后回车，将会发生的事情？</a>。另外，我在网络上搜索时看到了<a href="https://github.com/skyline75489/what-happens-when-zh_CN#id9" target="_blank" rel="external">当···时发生了什么？</a>，还有它的原文<a href="https://github.com/alex/what-happens-when/blob/master/README.rst" target="_blank" rel="external">What happens when…</a>，这篇在按下回车到HTTP连接成功作了很详细很详细的描述，真是太厉害了，本篇博客将两篇文章转了过来，然后结合在一起，如果有什么不合理的地方，请大家指正。</p>
<h2 id="按下”f”键"><a href="#按下”f”键" class="headerlink" title="按下”f”键"></a>按下”f”键</h2><p>两篇文章一篇用<code>google.com</code>，一篇用<code>facebook.com</code>作例子，这里统一用<code>facebook.com</code>。当你按下“f”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 “facebook.com”，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 “facebook” 建议给你。</p>
<h2 id="回车键按下"><a href="#回车键按下" class="headerlink" title="回车键按下"></a>回车键按下</h2><p>为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。</p>
<p>USB键盘：</p>
<ul>
<li>键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压</li>
<li>键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内</li>
<li>USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供</li>
<li>键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包</li>
<li>这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance）</li>
<li>这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层</li>
</ul>
<p>虚拟键盘（触屏设备）：</p>
<ul>
<li>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标</li>
<li>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮</li>
<li>虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息</li>
<li>这个消息又返回来向当前活跃的应用通知一个“按键按下”事件</li>
</ul>
<h2 id="产生中断-非USB键盘"><a href="#产生中断-非USB键盘" class="headerlink" title="产生中断[非USB键盘]"></a>产生中断[非USB键盘]</h2><p>键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。</p>
<h2 id="Windows-一个-WM-KEYDOWN-消息被发往应用程序"><a href="#Windows-一个-WM-KEYDOWN-消息被发往应用程序" class="headerlink" title="(Windows)一个 WM_KEYDOWN 消息被发往应用程序"></a>(Windows)一个 <code>WM_KEYDOWN</code> 消息被发往应用程序</h2><p>HID把键盘按下的事件传送给<code>KBDHID.sys</code>驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是<code>VK_RETURN(0x0d)</code>。<code>KBDHID.sys</code> 驱动和<code>KBDCLASS.sys</code>(键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用<code>Win32K.sys</code>，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。</p>
<p><code>Win32K.sys</code>通过<code>GetForegroundWindow()</code>API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”<code>message pump</code>“机制调用<code>SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam)</code>函数，<code>lParam</code>是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是<code>VK_RETURN</code>），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p>
<p>Windows的<code>SendMessage API</code>直接将消息添加到特定窗口句柄<code>hWnd</code>的消息队列中，之后赋给<code>hWnd</code>的主要消息处理函数<code>WindowProc</code>将会被调用，用于处理队列中的消息。</p>
<p>当前活跃的句柄<code>hWnd</code>实际上是一个edit control控件，这种情况下，<code>WindowProc</code>有一个用于处理<code>WM_KEYDOWN</code>消息的处理器，这段代码会查看<code>SendMessage</code>传入的第三个参数<code>wParam</code>，因为这个参数是<code>VK_RETURN</code>，于是它知道用户按下了回车键。</p>
<h2 id="Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序"><a href="#Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序" class="headerlink" title="(Mac OS X)一个 KeyDown NSEvent被发往应用程序"></a>(Mac OS X)一个 KeyDown NSEvent被发往应用程序</h2><p>中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的<code>WindowServer</code>进程。然后，<code>WindowServer</code>将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用<code>mach_ipc_dispatch</code>函数读取到。这个过程通常是由<code>NSApplication</code>主事件循环产生并且处理的，通过<code>NSEventType</code>为<code>KeyDown</code>的<code>NSEvent</code>。</p>
<h2 id="GNU-Linux-Xorg-服务器监听键码值"><a href="#GNU-Linux-Xorg-服务器监听键码值" class="headerlink" title="(GNU/Linux)Xorg 服务器监听键码值"></a>(GNU/Linux)Xorg 服务器监听键码值</h2><p>当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。</p>
<h2 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h2><p>浏览器通过 URL 能够知道下面的信息：</p>
<blockquote>
<p><code>Protocol</code> <em>“http”</em></p>
<ul>
<li>使用HTTP协议</li>
</ul>
<p><code>Resource</code> <em>“/“</em></p>
<ul>
<li>请求的资源是主页(index)</li>
</ul>
</blockquote>
<h2 id="输入的是-URL-还是搜索的关键字？"><a href="#输入的是-URL-还是搜索的关键字？" class="headerlink" title="输入的是 URL 还是搜索的关键字？"></a>输入的是 URL 还是搜索的关键字？</h2><p>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p>
<h2 id="ASCII-的-Unicode-字符"><a href="#ASCII-的-Unicode-字符" class="headerlink" title="ASCII 的 Unicode 字符"></a>ASCII 的 Unicode 字符</h2><ul>
<li>浏览器检查输入是否含有不是<code>a-z</code>，<code>A-Z</code>，<code>0-9</code>，<code>-</code>或者<code>.</code>的字符</li>
<li>这里主机名是<code>google.com</code>，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode 编码</li>
</ul>
<h2 id="检查-HSTS-列表···"><a href="#检查-HSTS-列表···" class="headerlink" title="检查 HSTS 列表···"></a>检查 HSTS 列表···</h2><ul>
<li>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站</li>
<li>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送</li>
<li>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户收到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。</li>
</ul>
<h2 id="DNS-查询···"><a href="#DNS-查询···" class="headerlink" title="DNS 查询···"></a>DNS 查询···</h2><ul>
<li>浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。</li>
<li>如果缓存中没有，就去调用<code>gethostbyname</code>库函数（操作系统不同函数也不同）进行查询。</li>
<li><code>gethostbyname</code>数在试图进行DNS解析之前首先检查域名是否在本地<code>Hosts</code>里，<code>Hosts</code>的位置 不同的操作系统有所不同</li>
<li>如果<code>gethostbyname</code>没有这个域名的缓存记录，也没有在<code>hosts</code>里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</li>
<li>查询本地 DNS 服务器</li>
<li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</li>
<li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li>
</ul>
<h2 id="ARP-过程"><a href="#ARP-过程" class="headerlink" title="ARP 过程"></a>ARP 过程</h2><p>要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p>
<ul>
<li>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC</li>
</ul>
<p>如果缓存没有命中：</p>
<ul>
<li>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</li>
<li>查询选择的网络接口的 MAC 地址</li>
<li>我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求：</li>
</ul>
<p><code>ARP Request:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Sender MAC: interface:mac:address:here</div><div class="line">Sender IP: interface.ip.goes.here</div><div class="line">Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)</div><div class="line">Target IP: target.ip.goes.here</div></pre></td></tr></table></figure></p>
<p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p>
<p>直连：</p>
<ul>
<li>如果我们和路由器是直接连接的，路由器会返回一个<code>ARP Reply</code>（见下面）。</li>
</ul>
<p>集线器：</p>
<ul>
<li>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个<code>ARP Reply</code>。</li>
</ul>
<p>交换机：</p>
<ul>
<li>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</li>
<li>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li>
<li>如果路由器也“连接”在其中，它会返回一个<code>ARP Reply</code></li>
</ul>
<p><code>ARP Reply:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Sender MAC: target:mac:address:here</div><div class="line">Sender IP: target.ip.goes.here</div><div class="line">Target MAC: interface:mac:address:here</div><div class="line">Target IP: interface.ip.goes.here</div></pre></td></tr></table></figure></p>
<p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p>
<ul>
<li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li>
<li>如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回</li>
</ul>
<p><img src="/2017/04/05/当你在浏览器地址栏输入一个URL后回车，将会发生的事情？/url_0.png" alt="DNS递归查找"></p>
<p>DNS有一点令人担忧，这就是像<code>wikipedia.org</code>或者<code>facebook.com</code>这样的整个域名看上去只是对应一个单独的IP地址。还好，有几种方法可以消除这个瓶颈：</p>
<ul>
<li>循环 DNS 是DNS查找时返回多个IP时的解决方案。举例来说，<code>facebook.com</code>实际上就对应了四个IP地址。</li>
<li>负载平衡器 是以一个特定IP地址进行侦听并将网络请求转发到集群服务器上的硬件设备。 一些大型的站点一般都会使用这种昂贵的高性能负载平衡器。</li>
<li>地理 DNS 根据用户所处的地理位置，通过把域名映射到多个不同的IP地址提高可扩展性。这样不同的服务器不能够更新同步状态，但映射静态内容的话非常好。</li>
<li>Anycast 是一个IP地址映射多个物理主机的路由技术。 美中不足，Anycast与TCP协议适应的不是很好，所以很少应用在那些方案中。</li>
</ul>
<p>大多数DNS服务器使用Anycast来获得高效低延迟的DNS查找。</p>
<h2 id="使用套接字"><a href="#使用套接字" class="headerlink" title="使用套接字"></a>使用套接字</h2><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数<code>socket</code>，请求一个 TCP流套接字，对应的参数是<code>AF_INET/AF_INET6</code>和<code>SOCK_STREAM</code>。</p>
<ul>
<li>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是<code>ip_local_port_range</code>)</li>
<li>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个TCP packet。</li>
<li>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame头 部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。</li>
</ul>
<p>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p>
<ul>
<li>以太网</li>
<li>WiFi</li>
<li>蜂窝数据网络</li>
</ul>
<p>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点 处理。节点的目标地址和源地址将在后面讨论。</p>
<p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。</p>
<p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部TTL域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p>
<p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p>
<ul>
<li>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号</li>
<li><p><strong><em>服务器端接收到 SYN 包，如果它可以建立连接：</em></strong></p>
<ul>
<li>服务器端选择它自己的初始序列号</li>
<li>服务器端设置 SYN 位，表明自己选择了一个初始序列号</li>
<li>服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包</li>
</ul>
</li>
<li><p><strong><em>客户端通过发送下面一个封包来确认这次连接：</em></strong></p>
<ul>
<li>自己的序列号+1</li>
<li>接收端 ACK+1</li>
<li>设置 ACK 位</li>
</ul>
</li>
<li><p><strong><em>数据通过下面的方式传输：</em></strong></p>
<ul>
<li>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N</li>
<li>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号</li>
</ul>
</li>
<li><p><strong><em>关闭连接时：</em></strong></p>
<ul>
<li>要关闭连接的一方发送一个 FIN 包</li>
<li>另一方确认这个 FIN 包，并且发送自己的 FIN 包</li>
<li>要关闭的一方使用 ACK 包来确认接收到了 FIN</li>
</ul>
</li>
</ul>
<h3 id="UDP-数据包"><a href="#UDP-数据包" class="headerlink" title="UDP 数据包"></a>UDP 数据包</h3><h2 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h2><ul>
<li>客户端发送一个<code>Client hello</code>消息到服务器端，消息中同时包含了它的TLS版本，可用的加密算法和压缩算法。</li>
<li>服务器端向客户端返回一个<code>Server hello</code>消息，消息中包含了服务器端的TLS版本，服务器选择了哪个加密和压缩算法，以及服务器的公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</li>
<li>客户端根据自己的信任CA列表，验证服务器端的证书是否有效。如果有效，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li>
<li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li>
<li>客户端发送一个<code>Finished</code>消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li>
<li>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个<code>Finished</code>消息，也使用协商好的对称密钥加密</li>
<li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</li>
</ul>
<h3 id="TCP-数据包"><a href="#TCP-数据包" class="headerlink" title="TCP 数据包"></a>TCP 数据包</h3><h2 id="HTTP-协议···"><a href="#HTTP-协议···" class="headerlink" title="HTTP 协议···"></a>HTTP 协议···</h2><p>如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。</p>
<p>如果浏览器使用 HTTP 协议，它会向服务器发送这样的一个请求:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">Host: google.com</div><div class="line">[其他头部]</div></pre></td></tr></table></figure>
<p>“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。这里我们假设浏览器没有违反HTTP协议标准的bug，同时浏览器使用<code>HTTP/1.1</code>协议，不然的话头部可能不包含<code>Host</code>字段，同时<code>GET</code>请求中的版本号会变成<code>HTTP/1.0</code>或者<code>HTTP/0.9</code>。</p>
<p>HTTP/1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开:</p>
<pre><code>Connection:close
</code></pre><p>不支持持久连接的 HTTP/1.1 必须在每条消息中都包含 “close” 选项。</p>
<p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p>
<p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">200 OK</div><div class="line">[响应头部]</div></pre></td></tr></table></figure>
<p>然后是一个换行，接下来有效载荷(payload)，也就是<code>www.google.com</code>的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供以后的请求重用。</p>
<p>如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部，以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">304 Not Modified</div><div class="line">[响应头部]</div></pre></td></tr></table></figure>
<p>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p>
<p>在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的<code>GET / HTTP/1.1</code>会变成<code>GET /$(相对www.google.com的URL) HTTP/1.1</code>。</p>
<p>如果HTML引入了<code>www.google.com</code>域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。</p>
<h2 id="HTTP-服务器请求处理"><a href="#HTTP-服务器请求处理" class="headerlink" title="HTTP 服务器请求处理"></a>HTTP 服务器请求处理</h2><p>HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p>
<ul>
<li>HTTPD 接收请求</li>
<li><p><strong><em>服务器把请求拆分为以下几个参数：</em></strong></p>
<ul>
<li>HTTP 请求方法(<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, 或者 <code>TRACE</code>)。直接在地址栏中输入 URL 这种情况下，使用的是<code>GET</code>方法</li>
<li>域名：google.com</li>
<li>请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)</li>
</ul>
</li>
<li><p>服务器验证其上已经配置了 google.com 的虚拟主机</p>
</li>
<li>服务器验证 google.com 接受 GET 方法</li>
<li>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</li>
<li>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</li>
<li>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</li>
<li>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者</li>
</ul>
<h2 id="服务器发回一个HTML响应"><a href="#服务器发回一个HTML响应" class="headerlink" title="服务器发回一个HTML响应"></a>服务器发回一个HTML响应</h2><p><img src="/2017/04/05/当你在浏览器地址栏输入一个URL后回车，将会发生的事情？/url_1.png" alt="服务器发回一个HTML相应"></p>
<p>图中为服务器生成并返回的响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line"> Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0,</div><div class="line"> pre-check=0</div><div class="line"> Expires: Sat, 01 Jan 2000 00:00:00 GMT</div><div class="line"> P3P: CP=&quot;DSP LAW&quot;</div><div class="line"> Pragma: no-cache</div><div class="line"> Content-Encoding: gzip</div><div class="line"> Content-Type: text/html; charset=utf-8</div><div class="line"> X-Cnection: close</div><div class="line"> Transfer-Encoding: chunked</div><div class="line"> Date: Fri, 12 Feb 2010 09:05:55 GMT </div><div class="line"> 2b3Tn@[...]</div></pre></td></tr></table></figure>
<p>整个响应大小为35kB，其中大部分在整理后以<code>blob</code>类型传输。</p>
<p>内容编码头告诉浏览器整个响应体用<code>gzip</code>算法进行压缩。解压<code>blob</code>块后，你可以看到如下期望的HTML：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;    </div><div class="line"> &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</div><div class="line"> &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;</div><div class="line"> lang=&quot;en&quot; id=&quot;facebook&quot; class=&quot; no_js&quot;&gt;</div><div class="line"> &lt;head&gt;</div><div class="line"> &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</div><div class="line"> &lt;meta http-equiv=&quot;Content-language&quot; content=&quot;en&quot; /&gt;</div><div class="line"> ...</div></pre></td></tr></table></figure>
<p>关于压缩，头信息说明了是否缓存这个页面，如果缓存的话如何去做，有什么<code>cookies</code>要去设置（前面这个响应里没有这点）和隐私信息等等。</p>
<p>请注意报头中把<code>Content-type</code>设置为“<code>text/html</code>”。报头让浏览器将该响应内容以HTML形式呈现，而不是以文件形式下载它。浏览器会根据报头信息决定如何解释该响应，不过同时也会考虑像URL扩展内容等其他因素。</p>
<h2 id="浏览器背后的故事"><a href="#浏览器背后的故事" class="headerlink" title="浏览器背后的故事"></a>浏览器背后的故事</h2><p>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p>
<ul>
<li>解析 —— HTML，CSS，JS</li>
<li>渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</li>
</ul>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。</p>
<p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。</p>
<p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p>
<ul>
<li>一个地址栏</li>
<li>后退和前进按钮</li>
<li>书签选项</li>
<li>刷新和停止按钮</li>
<li>主页按钮</li>
</ul>
<h3 id="浏览器高层架构"><a href="#浏览器高层架构" class="headerlink" title="浏览器高层架构"></a>浏览器高层架构</h3><p>组成浏览器的组件有：</p>
<ul>
<li><strong>用户界面</strong> 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分</li>
<li><strong>浏览器引擎</strong> 浏览器引擎负责让 UI 和渲染引擎协调工作</li>
<li><strong>渲染引擎</strong> 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上</li>
<li><strong>网络组件</strong> 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</li>
<li><strong>UI后端</strong> UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</li>
<li><strong>Javascript引擎</strong> Javascript 引擎用于解析和执行 Javascript 代码</li>
<li><strong>数据存储</strong> 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</li>
</ul>
<h2 id="HTML-解析"><a href="#HTML-解析" class="headerlink" title="HTML 解析"></a>HTML 解析</h2><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。</p>
<p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p>
<p>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p>
<h3 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h3><p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p>
<ul>
<li>语言本身的“宽容”特性</li>
<li>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们</li>
<li>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容</li>
</ul>
<p>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p>
<h3 id="解析结束之后"><a href="#解析结束之后" class="headerlink" title="解析结束之后"></a>解析结束之后</h3><p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p>
<p>此时浏览器把文档标记为“可交互的”，浏览器开始解析处于“推迟”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成”，浏览器会进行“加载”事件。</p>
<p>注意解析 HTML 网页时永远不会出现“语法错误”，浏览器会修复所有错误，然后继续解析。</p>
<p>执行同步 Javascript 代码。</p>
<h2 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h2><ul>
<li>根据 CSS词法和句法 分析CSS文件和<code>&lt;style&gt;</code>标签包含的内容</li>
<li>每个CSS文件都被解析成一个样式表对象，这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象</li>
<li>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</li>
</ul>
<h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><ul>
<li>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值</li>
<li>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点首的选(preferred)宽度</li>
<li>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度</li>
<li>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度</li>
<li>使用上面的计算结果构建每个节点的坐标</li>
<li>当存在元素使用<code>floated</code>，位置有<code>absolutely</code>或<code>relatively</code>属性的时候，会有更多复杂的计算，详见<a href="http://dev.w3.org/csswg/css2/" target="_blank" rel="external">http://dev.w3.org/csswg/css2/</a> 和 <a href="http://www.w3.org/Style/CSS/current-work" target="_blank" rel="external">http://www.w3.org/Style/CSS/current-work</a></li>
<li>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层</li>
<li>页面上的每个层都被分配了纹理(?)</li>
<li>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制</li>
<li>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量</li>
<li>计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</li>
</ul>
<h2 id="GPU-渲染"><a href="#GPU-渲染" class="headerlink" title="GPU 渲染"></a>GPU 渲染</h2><ul>
<li>在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU</li>
<li>当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</li>
</ul>
<h2 id="浏览器发送异步（AJAX）请求"><a href="#浏览器发送异步（AJAX）请求" class="headerlink" title="浏览器发送异步（AJAX）请求"></a>浏览器发送异步（AJAX）请求</h2><p><img src="/2017/04/05/当你在浏览器地址栏输入一个URL后回车，将会发生的事情？/url_2.png" alt="发送AJAX请求"></p>
<p>在Web 2.0伟大精神的指引下，页面显示完成后客户端仍与服务器端保持着联系。</p>
<p>以 Facebook聊天功能为例，它会持续与服务器保持联系来及时更新你那些亮亮灰灰的好友状态。为了更新这些头像亮着的好友状态，在浏览器中执行的 JavaScript代码会给服务器发送异步请求。这个异步请求发送给特定的地址，它是一个按照程式构造的获取或发送请求。还是在Facebook这个例 子中，客户端发送给<code>http://www.facebook.com/ajax/chat/buddy_list.php</code>一个发布请求来获取你好友里哪个 在线的状态信息。</p>
<p>提起这个模式，就必须要讲讲”AJAX”– “异步JavaScript 和 XML”，虽然服务器为什么用XML格式来进行响应也没有个一清二白的原因。再举个例子吧，对于异步请求，Facebook会返回一些JavaScript的代码片段。</p>
<p>除了其他，<code>fiddler</code>这个工具能够让你看到浏览器发送的异步请求。事实上，你不仅可以被动的做为这些请求的看客，还能主动出击修改和重新发送它们。AJAX请求这么容易被蒙，可着实让那些计分的在线游戏开发者们郁闷的了。（当然，可别那样骗人家~）</p>
<p>Facebook聊天功能提供了关于AJAX一个有意思的问题案例：把数据从服务器端推送到客户端。因为HTTP是一个请求-响应协议，所以聊天服务器不能把新消息发给客户。取而代之的是客户端不得不隔几秒就轮询下服务器端看自己有没有新消息。</p>
<p>这些情况发生时长轮询是个减轻服务器负载挺有趣的技术。如果当被轮询时服务器没有新消息，它就不理这个客户端。而当尚未超时的情况下收到了该客户的新消息，服务器就会找到未完成的请求，把新消息做为响应返回给客户端。</p>
<h2 id="Window-Server"><a href="#Window-Server" class="headerlink" title="Window Server"></a>Window Server</h2><h2 id="后期渲染与用户引发的处理"><a href="#后期渲染与用户引发的处理" class="headerlink" title="后期渲染与用户引发的处理"></a>后期渲染与用户引发的处理</h2><p>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次学习，对这方面的一系列过程有了比较深的了解。</p>
]]></content:encoded>
      
      <comments>http://yoursite.com/2017/04/05/%E5%BD%93%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%90%8E%E5%9B%9E%E8%BD%A6%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Socks5与VPN在原理上的异同</title>
      <link>http://yoursite.com/2017/04/04/Socks5%E4%B8%8EVPN%E5%9C%A8%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <guid>http://yoursite.com/2017/04/04/Socks5%E4%B8%8EVPN%E5%9C%A8%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <pubDate>Tue, 04 Apr 2017 14:45:32 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;之前一直是用vpn科学上网的，前几天买了个国外VPS搭建了Shadowsocks。都是翻墙的工具，就想了解了解其中不同的地方，看到了这篇文章
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前一直是用vpn科学上网的，前几天买了个国外VPS搭建了Shadowsocks。都是翻墙的工具，就想了解了解其中不同的地方，看到了这篇文章：<a href="http://www.tennfy.com/3412.html" target="_blank" rel="external">Socks5与VPN在原理上的异同</a>，很有收获，转了过来，很感谢作者。</p>
<h2 id="Socks5原理介绍"><a href="#Socks5原理介绍" class="headerlink" title="Socks5原理介绍"></a>Socks5原理介绍</h2><h3 id="Socket套接字介绍"><a href="#Socket套接字介绍" class="headerlink" title="Socket套接字介绍"></a>Socket套接字介绍</h3><p>Socket套接字实际上是基于TCP/IP的一组应用程序接口，应用层的程序通过调用Socket套接字来实现网络间的进程通信。</p>
<h3 id="Socks5原理介绍-1"><a href="#Socks5原理介绍-1" class="headerlink" title="Socks5原理介绍"></a>Socks5原理介绍</h3><p>Socks5是一个代理协议，位于传输层(TCP/UDP等)与应用层之间。Socks软件包组成为如下结构：</p>
<p>Socks库：安装于客户端。为Socket库的替代品，所有使用Socks的程序都必须将Socket库函数调用更改为Socks库函数调用。需要注意的是，Socks库函数仍然需要调用Socket库函数，Socks仅仅是在其上做了安全验证。</p>
<p>Sockd守护程序：安装于服务器，接收并处理来自客户端的<code>CONNECT</code>，<code>BIND</code>及<code>UDP associate</code>请求。以<code>CONNECT</code>请求为例，其工作流程为：</p>
<ul>
<li>客户端向代理服务器发出请求信息，用以协商版本和认证方法</li>
<li>代理服务器应答，将选择的方法发送给客户端</li>
<li>客户和代理服务器进入由选定认证方法所决定的子协商过程</li>
<li>子协商过程结束后，客户端发送请求信息，其中明了目标服务器的IP地址和端口</li>
<li>代理服务器验证客户端身份，验证通过后会与目标服务器连接</li>
<li>代理服务器向客户端返回连接信息</li>
<li>若连接完成，则代理服务器开始作为中转站中转数据</li>
</ul>
<p>Socks5协议同时支持TCP及UDP代理，它主要工作与会话层，因此与上层的协议无关。但是，它无法做到全局代理。</p>
<h2 id="VPN原理介绍"><a href="#VPN原理介绍" class="headerlink" title="VPN原理介绍"></a>VPN原理介绍</h2><p>VPN，Virtual Private Network（虚拟专用网络），被定义为通过一个公用网络（通常是因特网）建立一个临时的、安全的连接，是一条穿过公用网络的安全、稳定的隧道。VPN有很多种实现方式，常见的有PPTP，L2TP ,L2TP over IPSEC等等。</p>
<p>以OSI 模型参照标准，不同的VPN术可以在不同的OSI协议层实现。如下表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VPN在OSI中的层次       VPN实现技术 </div><div class="line">应用层                 SSL VPN </div><div class="line">会话层                 Socks5 VPN </div><div class="line">网络层                 IPSec VPN </div><div class="line">数据链路层              PPTP及L2TP</div></pre></td></tr></table></figure>
<h3 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h3><p>隧道技术的基本过程是在源局域网与公网的接口处将数据(可以是OSI七层模型中的数据链路层或网络层数据)作为负载封装在一种可以在公网上传输的数据格式中，在目的局域网与公网的接口处将数据解封装，取出负载。被封装的数据包在互联网上传递时所经过的逻辑路径被称为“隧道”。</p>
<h3 id="PPTP-VPN技术"><a href="#PPTP-VPN技术" class="headerlink" title="PPTP VPN技术"></a>PPTP VPN技术</h3><p>PPTP（点到点隧道协议）是由PPTP论坛开发的点到点的安全隧道协议，为使用电话上网的用户提供安全VPN业务，1996年成为IETF草案。PPTP是PPP协议的一种扩展，提供了在IP网上建立多协议的安全VPN的通信方式，远端用户能够通过任何支持PPTP的ISP访问企业的专用网络。</p>
<p>PPTP使用一个TCP连接对隧道进行维护，使用通用路由封装（GRE）技术把数据封装成PPP数据桢通过隧道传送。可以对封装PPP桢中的负载数据进行加密或压缩。<br>下边简单描述PPTP 过程中涉及的封装和解封步骤。</p>
<p>封装：<br>1.数据封装于 IP (或 IPX 和 NetBEUI )封包中。<br>2.该 IP (或 IPX 和 NetBEUI )封包封装在 PPP 帧中。<br>3.该 PPP 帧封装在 GRE 帧中（并加密）。<br>4.该 GRE 帧封装在 IP 封包中。</p>
<p>解封：<br>1.移除IP 包头。<br>2.移除GRE 包头(解密过程)。GRE负载中是一个PPP帧。<br>3.移除PPP 包头。<br>4.将该IP(或IPX和NetBEUI)封包路由到其最终的目的地。</p>
<p>MPPE将通过由MS-CHAP、MS-CHAP v2或EAP-TLS身份验证过程所生成的加密密钥对PPP帧进行加密。为对PPP帧中所包含的有效数据进行加密，虚拟专用网络客户端必须使用MS-CHAP、MS-CHAP v2或EAP-TLS身份验证协议。PPTP将利用底层PPP加密功能并直接对原先经过加密的PPP帧进行封装。</p>
<p>PPTP协议将控制包与数据包分开，控制包采用TCP控制，客户端连接到VPN服务器TCP1723端口，用于控制和管理VPN隧道的功能；数据包部分先封装在PPP协议中，然后封装到GRE V2协议中，最后封装到IP协议中传送。</p>
<p>可以看出来，VPN技术主要应用于IP层及以下，因此不依赖与具体的应用，所以可以实现全局代理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然这篇博客说得有点简单了，但是重要的点都点出来了，也说得很清楚，很感谢作者。</p>
]]></content:encoded>
      
      <comments>http://yoursite.com/2017/04/04/Socks5%E4%B8%8EVPN%E5%9C%A8%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%BC%82%E5%90%8C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux Socket编程</title>
      <link>http://yoursite.com/2017/04/04/Linux-Socket%E7%BC%96%E7%A8%8B/</link>
      <guid>http://yoursite.com/2017/04/04/Linux-Socket%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Tue, 04 Apr 2017 06:02:27 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文转载&lt;a href=&quot;http://www.cnblogs.com/skynet/&quot; target=&quot;_blank&quot; rel=&quot;exte
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文转载<a href="http://www.cnblogs.com/skynet/" target="_blank" rel="external">Linux Socket编程（不限Linux）</a>，作者：吴秦，写得很好，又具体又全面，有例子，看完很有收获，就转了过来。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“一切皆Socket！”</p>
<p>话虽些许夸张，但是事实也是，现在的网络编程几乎都是用的socket。</p>
<p>——有感于实际编程和开源项目研究。</p>
<p>我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数，这些都是本文想介绍的。本文的主要内容如下：</p>
<ul>
<li>网络中进程之间如何通信？</li>
<li>Socket是什么？</li>
<li>socket的基本操作<ul>
<li>socket()函数</li>
<li>bind()函数</li>
<li>listen()、connect()函数</li>
<li>accept()函数</li>
<li>read()、write()函数等</li>
<li>close()函数</li>
</ul>
</li>
<li>socket中TCP的三次握手建立连接详解</li>
<li>socket中TCP的四次握手释放连接详解</li>
<li>一个例子（实践一下）</li>
</ul>
<h2 id="网络中进程之间如何通信？"><a href="#网络中进程之间如何通信？" class="headerlink" title="网络中进程之间如何通信？"></a>网络中进程之间如何通信？</h2><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，<strong>网络层的ip地址</strong>可以唯一标识网络中的主机，而<strong>传输层的协议+端口</strong>可以唯一标识主机中的应用程序（进程）。这样利用三元组（<strong>ip地址，协议，端口</strong>）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX  BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。</p>
<h2 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h2><p>上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。</p>
<blockquote>
<p><strong>socket一词的起源</strong>：在组网领域的首次使用是在1970年2月12日发布的文献IETF RFC33中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”</p>
</blockquote>
<h2 id="socket的基本操作"><a href="#socket的基本操作" class="headerlink" title="socket的基本操作"></a>socket的基本操作</h2><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p>
<h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h3><pre><code>int socket(int domain, int type, int protocol);
</code></pre><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而<code>socket()</code>用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<p>正如可以给<code>fopen()</code>的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p>
<p><code>domain</code>：即协议域，又称为协议族（family）。常用的协议族有<code>AF_INET</code>、<code>AF_INET6</code>、<code>AF_LOCAL</code>（或称<code>AF_UNIX</code>，Unix域socket）、<code>AF_ROUTE</code>等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如<code>AF_INET</code>决定了要用ipv4地址（32位的）与端口号（16位的）的组合、<code>AF_UNIX</code>决定了要用一个绝对路径名作为地址。<br><code>type</code>：指定socket类型。常用的socket类型有：<br><code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、<code>SOCK_RAW</code>、<code>SOCK_PACKET</code>、<code>SOCK_SEQPACKET</code>等等。<br><code>protocol</code>：顾名思义，就是指定协议。常用的协议有：<br><code>IPPROTO_TCP</code>、<code>IPPTOTO_UDP</code>、<code>IPPROTO_SCTP</code>、<code>IPPROTO_TIPC</code>等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。<br>注意：并不是上面的type和protocol可以随意组合的，如<code>SOCK_STREAM</code>不可以跟<code>IPPROTO_UDP</code>组合。当<code>protocol</code>为0时，会自动选择type类型对应的默认协议。</p>
<p>当我们调用<code>socket()</code>创建一个socket时，返回的socket描述字它存在于协议族<code>(address family, AF_XXX)</code>空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用<code>bind()</code>函数，否则就当调用<code>connect()</code>、<code>listen()</code>时系统会自动随机分配一个端口。</p>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h3><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应<code>AF_INET</code>、<code>AF_INET6</code>就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<pre><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre><p>函数的三个参数分别为：<br><code>sockfd</code>：即socket描述字，它是通过<code>socket()</code>函数创建了唯一标识一个socket。<code>bind()</code>函数就是将给这个描述字绑定一个名字。<br><code>addr</code>：一个<code>const struct sockaddr *</code>指针，指向要绑定给<code>sockfd</code>的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct sockaddr_in &#123;</div><div class="line">    sa_family_t    sin_family; /* address family: AF_INET */</div><div class="line">    in_port_t      sin_port;   /* port in network byte order */</div><div class="line">    struct in_addr sin_addr;   /* internet address */</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* Internet address. */</div><div class="line">struct in_addr &#123;</div><div class="line">    uint32_t       s_addr;     /* address in network byte order */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>ipv6对应的是： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct sockaddr_in6 &#123; </div><div class="line">    sa_family_t     sin6_family;   /* AF_INET6 */ </div><div class="line">    in_port_t       sin6_port;     /* port number */ </div><div class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </div><div class="line">    struct in6_addr sin6_addr;     /* IPv6 address */ </div><div class="line">    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ </div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct in6_addr &#123; </div><div class="line">    unsigned char   s6_addr[16];   /* IPv6 address */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Unix域对应的是： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define UNIX_PATH_MAX    108</div><div class="line"></div><div class="line">struct sockaddr_un &#123; </div><div class="line">    sa_family_t sun_family;               /* AF_UNIX */ </div><div class="line">    char        sun_path[UNIX_PATH_MAX];  /* pathname */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>addrlen</code>：对应的是地址的长度。</p>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户端就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用<code>bind()</code>，而客户端就不会调用，而是在<code>connect()</code>时由系统随机生成一个。</p>
<blockquote>
<p><strong>网络字节序与主机字节序</strong>：<br><strong>主机字节序</strong>就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：<br>1.Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>2.Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br><strong>网络字节序</strong>：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p>
</blockquote>
<p>所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</p>
<h3 id="listen-、connect-函数"><a href="#listen-、connect-函数" class="headerlink" title="listen()、connect()函数"></a>listen()、connect()函数</h3><p>如果作为一个服务器，在调用<code>socket()</code>、<code>bind()</code>之后就会调用<code>listen()</code>来监听这个socket，如果客户端这时调用<code>connect()</code>发出连接请求，服务器端就会接收到这个请求。</p>
<pre><code>int listen(int sockfd, int backlog);
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。<code>socket()</code>函数创建的socket默认是一个主动类型的，<code>listen()</code>函数将socket变为被动类型的，等待客户的连接请求。</p>
<p><code>connect()</code>函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h3><p>TCP服务器端依次调用<code>socket()</code>、<code>bind()</code>、<code>listen()</code>之后，就会监听指定的socket地址了。TCP客户端依次调用<code>socket()</code>、<code>connect()</code>之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用<code>accept()</code>函数去接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p>
<pre><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre><p><code>accept()</code>函数的第一个参数为服务器的socket描述字，第二个参数为指向<code>struct sockaddr *</code>的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用<code>socket()</code>函数生成的，称为监听socket描述字；而<code>accept()</code>函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<h3 id="read-、write-等函数"><a href="#read-、write-等函数" class="headerlink" title="read()、write()等函数"></a>read()、write()等函数</h3><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网络中不同进程之间的通信，网络I/O操作有下面几组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">read()/write()</div><div class="line">recv()/send()</div><div class="line">readv()/writev()</div><div class="line">recvmsg()/sendmsg()</div><div class="line">recvfrom()/sendto()</div></pre></td></tr></table></figure>
<p>我推荐使用<code>recvmsg()/sendmsg()</code>函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">ssize_t read(int fd, void *buf, size_t count);</div><div class="line">ssize_t write(int fd, const void *buf, size_t count);</div><div class="line"></div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line"></div><div class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</div><div class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</div><div class="line"></div><div class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</div><div class="line">			  const struct sockaddr *dest_addr, socklen_t addrlen);</div><div class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</div><div class="line">				struct sockaddr *src_addr, socklen_t *addrlen);</div><div class="line"></div><div class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</div><div class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</div></pre></td></tr></table></figure>
<p><code>read()</code>函数是负责从fd中读取内容，当读成功时，<code>read()</code>返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为<code>EINTR</code>说明读是由中断引起的，如果是<code>ECONNREST</code>表示网络连接出了问题。</p>
<p><code>write()</code>函数将buf中的n bytes字节内容写入文件描述符fd，成功时返回写的字节数。失败时返回-1，并设置<code>errno</code>变量。 在网络程序中，当我们向套接字文件描述符写时有两种可能：</p>
<ul>
<li>write的返回值大于0，表示写了部分或者是全部的数据。</li>
<li>返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</li>
</ul>
<p>其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、google，下面的例子中将使用到<code>send()/recv()</code>。</p>
<h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close()函数"></a>close()函数</h3><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用<code>fclose()</code>关闭打开的文件。</p>
<pre><code>#include &lt;unistd.h&gt;
int close(int fd);
</code></pre><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为<code>read()</code>或<code>write()</code>的第一个参数。</p>
<p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
<h2 id="socket中TCP的三次握手建立连接详解"><a href="#socket中TCP的三次握手建立连接详解" class="headerlink" title="socket中TCP的三次握手建立连接详解"></a>socket中TCP的三次握手建立连接详解</h2><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p>
<ul>
<li>客户端向服务器发送一个SYN J</li>
<li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li>
<li>客户端再想服务器发一个确认ACK K+1</li>
</ul>
<p>只有做完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：</p>
<p><img src="/2017/04/04/Linux-Socket编程/socket_0.png" alt="socket中发送的TCP三次握手"></p>
<p>从图中可以看出，当客户端调用<code>connect()</code>时，触发了连接请求，向服务器发送了SYN J包，这时<code>connect()</code>进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用<code>accept()</code>函数接收请求向客户端发送SYN K ，ACK J+1，这时<code>accept()</code>进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时<code>connect()</code>返回，并对SYN K进行确认；服务器收到ACK K+1时，<code>0accept()</code>返回，至此三次握手完毕，连接建立。</p>
<p>总结：客户端的<code>connect()</code>在三次握手的第二次返回，而服务器端的<code>accept()</code>在三次握手的第三次返回。</p>
<h2 id="socket中TCP的四次握手释放连接详解"><a href="#socket中TCP的四次握手释放连接详解" class="headerlink" title="socket中TCP的四次握手释放连接详解"></a>socket中TCP的四次握手释放连接详解</h2><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的<code>socket()</code>函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：</p>
<p><img src="/2017/04/04/Linux-Socket编程/socket_1.png" alt="socket中发送的TCP四次握手"></p>
<p>图示过程如下：</p>
<ul>
<li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li>
<li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li>
<li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li>
<li>接收到这个FIN的源发送端TCP对它进行确认。</li>
</ul>
<p>这样每个方向上都有一个FIN和ACK。</p>
<h2 id="一个例子（实践一下）"><a href="#一个例子（实践一下）" class="headerlink" title="一个例子（实践一下）"></a>一个例子（实践一下）</h2><p>说了这么多了，动手实践一下。下面编写一个简单的服务器、客户端（使用TCP）——服务器端一直监听本机的6666号端口，如果收到连接请求，将接收请求并接收客户端发来的消息；客户端与服务器端建立连接并发送一条消息。</p>
<p>服务器端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;string.h&gt;</div><div class="line">#include&lt;errno.h&gt;</div><div class="line">#include&lt;sys/types.h&gt;</div><div class="line">#include&lt;sys/socket.h&gt;</div><div class="line">#include&lt;netinet/in.h&gt;</div><div class="line"></div><div class="line">#define MAXLINE 4096</div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">&#123;</div><div class="line">    int    listenfd, connfd;</div><div class="line">    struct sockaddr_in     servaddr;</div><div class="line">    char    buff[4096];</div><div class="line">    int     n;</div><div class="line"></div><div class="line">    if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 )&#123;</div><div class="line">    printf(&quot;create socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);</div><div class="line">    exit(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    memset(&amp;servaddr, 0, sizeof(servaddr));</div><div class="line">    servaddr.sin_family = AF_INET;</div><div class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</div><div class="line">    servaddr.sin_port = htons(6666);</div><div class="line"></div><div class="line">    if( bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) == -1)&#123;</div><div class="line">    printf(&quot;bind socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);</div><div class="line">    exit(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if( listen(listenfd, 10) == -1)&#123;</div><div class="line">    printf(&quot;listen socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);</div><div class="line">    exit(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    printf(&quot;======waiting for client&apos;s request======\n&quot;);</div><div class="line">    while(1)&#123;</div><div class="line">    if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1)&#123;</div><div class="line">        printf(&quot;accept socket error: %s(errno: %d)&quot;,strerror(errno),errno);</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line">    n = recv(connfd, buff, MAXLINE, 0);</div><div class="line">    buff[n] = &apos;\0&apos;;</div><div class="line">    printf(&quot;recv msg from client: %s\n&quot;, buff);</div><div class="line">    close(connfd);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    close(listenfd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;string.h&gt;</div><div class="line">#include&lt;errno.h&gt;</div><div class="line">#include&lt;sys/types.h&gt;</div><div class="line">#include&lt;sys/socket.h&gt;</div><div class="line">#include&lt;netinet/in.h&gt;</div><div class="line"></div><div class="line">#define MAXLINE 4096</div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">&#123;</div><div class="line">    int    sockfd, n;</div><div class="line">    char    recvline[4096], sendline[4096];</div><div class="line">    struct sockaddr_in    servaddr;</div><div class="line"></div><div class="line">    if( argc != 2)&#123;</div><div class="line">    printf(&quot;usage: ./client &lt;ipaddress&gt;\n&quot;);</div><div class="line">    exit(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)&#123;</div><div class="line">    printf(&quot;create socket error: %s(errno: %d)\n&quot;, strerror(errno),errno);</div><div class="line">    exit(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    memset(&amp;servaddr, 0, sizeof(servaddr));</div><div class="line">    servaddr.sin_family = AF_INET;</div><div class="line">    servaddr.sin_port = htons(6666);</div><div class="line">    if( inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0)&#123;</div><div class="line">    printf(&quot;inet_pton error for %s\n&quot;,argv[1]);</div><div class="line">    exit(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if( connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0)&#123;</div><div class="line">    printf(&quot;connect error: %s(errno: %d)\n&quot;,strerror(errno),errno);</div><div class="line">    exit(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    printf(&quot;send msg to server: \n&quot;);</div><div class="line">    fgets(sendline, 4096, stdin);</div><div class="line">    if( send(sockfd, sendline, strlen(sendline), 0) &lt; 0)</div><div class="line">    &#123;</div><div class="line">    printf(&quot;send msg error: %s(errno: %d)\n&quot;, strerror(errno), errno);</div><div class="line">    exit(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    close(sockfd);</div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然上面的代码很简单，也有很多缺点，这就只是简单的演示socket的基本函数使用。其实不管有多复杂的网络程序，都使用的这些基本函数。上面的服务器使用的是迭代模式的，即只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力是很弱的，现实中的服务器都需要有并发处理能力。为了需要并发处理，服务器需要<code>fork()</code>一个新的进程或者线程去处理请求等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是介绍了简单的socket编程，更为复杂的需要自己继续深入。</p>
]]></content:encoded>
      
      <comments>http://yoursite.com/2017/04/04/Linux-Socket%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>搭建Shadowsocks并使用</title>
      <link>http://yoursite.com/2017/04/03/%E6%90%AD%E5%BB%BAShadowsocks%E5%B9%B6%E4%BD%BF%E7%94%A8/</link>
      <guid>http://yoursite.com/2017/04/03/%E6%90%AD%E5%BB%BAShadowsocks%E5%B9%B6%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Mon, 03 Apr 2017 02:04:53 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;之前科学上网用的是VPN，&lt;a href=&quot;https://www.greenjsq.me/&quot; target=&quot;_blank&quot; rel=&quot;e
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前科学上网用的是VPN，<a href="https://www.greenjsq.me/" target="_blank" rel="external">green</a>的VPN很稳定，速度也快，一个月18元也不算贵，这次搭建Shadowsocks是自己感兴趣，所以尝试搭建了下，写了下来。</p>
<h2 id="买个VPS"><a href="#买个VPS" class="headerlink" title="买个VPS"></a>买个VPS</h2><p>关于国外VPS买哪一家好，可以看<a href="http://www.laozuo.org/myvps" target="_blank" rel="external">老左博客</a>，介绍很全面详细，我自己选的是<a href="https://www.vultr.com/" target="_blank" rel="external">Vultr</a>，老左里面说的活动好像都过期了。</p>
<p>注册Vultr账号和<a href="https://www.paypal.com/c2/webapps/mpp/account-selection" target="_blank" rel="external">Paypal</a>账号。<br>PS: 用于付款，不想注册Paypal的话，可以试试搬瓦工，可以用支付宝，具体见老左博客。</p>
<p>新建实例：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_0.png" alt="Location"></p>
<p>服务器位置，一般看你自己经常访问的网址主要在哪里。</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_1.png" alt="Type"></p>
<p>服务器系统一般选CentOS，配置我是选的最低（毕竟穷）。</p>
<p>这样创建之后一个月2.5刀，有500G流量，够用也不算贵。用Paypal付款成功之后，就可以看到你的VPS。</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_2.png" alt="VPS"></p>
<h2 id="安装Shadowsocks"><a href="#安装Shadowsocks" class="headerlink" title="安装Shadowsocks"></a>安装Shadowsocks</h2><p>使用<a href="http://www.netsarang.com/products/xsh_overview.html" target="_blank" rel="external">Xshell5</a>或者<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank" rel="external">PuTTY</a>连接刚买的VPS，接收密钥，输入用户名<code>root</code>，密码直接复制上面的Password，连接成功。</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_3.png" alt="连接VPS"></p>
<p>之后输入以下命令：</p>
<pre><code>wget no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh
chmod +x shadowsocks.sh
./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log
</code></pre><p>输入完回车可以看到以下这个界面：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_4.png" alt="ss设置"></p>
<p>设置密码、端口，敲任意键开始安装设置，完成之后将出现以下信息：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_5.png" alt="ss信息"></p>
<p>到这里，Shadowsocks已经搭建好了，如果想卸载则执行：</p>
<pre><code>./shadowsocks.sh uninstall
</code></pre><h2 id="安装Kcptun给Shadowsocks加速"><a href="#安装Kcptun给Shadowsocks加速" class="headerlink" title="安装Kcptun给Shadowsocks加速"></a>安装Kcptun给Shadowsocks加速</h2><p>Kcptun，一个免费的加速工具。它是一个非常简单和快速的，基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。而 KCP 是一个快速可靠协议，能以比 TCP 浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。</p>
<p>安装执行以下命令：</p>
<pre><code>wget https://raw.githubusercontent.com/kuoruan/kcptun_installer/master/kcptun.sh
chmod +x ./kcptun.sh
./kcptun.sh
</code></pre><p>执行完成，将看到以下界面：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_6.png" alt="Kcptun设置"></p>
<h3 id="设置Kcptun服务端端口"><a href="#设置Kcptun服务端端口" class="headerlink" title="设置Kcptun服务端端口"></a>设置Kcptun服务端端口</h3><p>请输入一个未被占用的端口，Kcptun 运行时将使用此端口。</p>
<h3 id="设置加速的-IP"><a href="#设置加速的-IP" class="headerlink" title="设置加速的 IP"></a>设置加速的 IP</h3><p>如果你想加速 Shadowsocks，而 Shadowsocks 就在运行在当前服务器上，直接回车即可。如果 Shadowsocks 运行在其他服务器，请输入服务器的 IP 地址。这也就是说，Kcptun 不仅能加速本地的端口，也能加速远端的端口。</p>
<h3 id="设置加速的端口"><a href="#设置加速的端口" class="headerlink" title="设置加速的端口"></a>设置加速的端口</h3><p>输入上面Shadowsocks设置的服务端口。</p>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>不输入的话，有个默认密码<code>it&#39;s a secrect</code>。</p>
<p>设置完成，安装成功之后，可以看到以下输出信息：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_7.png" alt="Kcptun信息"></p>
<p>这些信息记得保存下来，待会客户端配置的时候需要用到。</p>
<p>Kcptun有关命令：</p>
<pre><code>./kcptun.sh update    #更新
./kcptun.sh reconfig    #重新配置
./kcptun.sh uninstall    #卸载
</code></pre><p>到这里，服务器上的配置就已经完成了，接下来是客户端的配置。</p>
<h2 id="Shadowsocks-Android"><a href="#Shadowsocks-Android" class="headerlink" title="Shadowsocks-Android"></a>Shadowsocks-Android</h2><p>下载<a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="external">apk客户端</a></p>
<p>安装，打开影梭，界面：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_8.png" alt="影梭安卓界面"></p>
<p>新建并设置：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_9.png" alt="影梭安卓设置"></p>
<p>服务器就填服务器的IP，远程端口是填Shadowsocks的服务端口，加密方法就填Shandowsocks设置的加密方法。</p>
<p>配置完成之后，测试一下能否正常联网，如果可以的话，再配置KCP协议。</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_10.png" alt="连接成功"></p>
<p>在新版的Shadowsocks安卓客户端，Kcptun是作为插件来安装的，所以我们得下个<a href="https://github.com/shadowsocks/kcptun-android/releases" target="_blank" rel="external">Kcptun插件</a>，下载完安装，可以看到配置文件中最下面的插件有了Kcptun：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_11.png" alt="Kcptun插件"></p>
<p>接下来是参数的设置，可以看到服务器Kcptun的配置信息：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_12.png" alt="Kcptun服务端信息"></p>
<p>然后是手机端的配置：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_13.png" alt="Kcp手机端配置"></p>
<p>这里的参数是用<code>key=value</code>的格式来配置的。另外，如果这个参数是boolean类型，写了参数就表示<code>true</code>，没写则表示<code>false</code>。可以看到右下角有个问号，点开可以看到一些默认参数，对于那些默认值相同的就可以不写了，对照我的服务端配置：</p>
<pre><code>sndwnd=512;remoteaddr=45.32.137.118:29900;key=123456;mode=fast2
</code></pre><p>设置成功后，保存重新连接，可以发现，速度快了很多，不过，相对地，流量也会多走……</p>
<h2 id="Shadowsocks-Windows"><a href="#Shadowsocks-Windows" class="headerlink" title="Shadowsocks-Windows"></a>Shadowsocks-Windows</h2><p>Windows下，我们总共需要下载三个东西，<a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="external">Kcptun客户端</a>、<a href="https://github.com/dfdragon/kcptun_gclient/releases" target="_blank" rel="external">Kcptun管理工具</a>、<a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="external">Shadowsocks客户端</a>。这里要注意，Kcptun客户端的版本要跟Kcptun服务端的版本一样，Kcptun服务端的版本如下：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_12.png" alt="Kcptun版本"></p>
<h3 id="Kcptun配置"><a href="#Kcptun配置" class="headerlink" title="Kcptun配置"></a>Kcptun配置</h3><p>接下来是配置Kcptun管理工具，我之前配置的时候，逻辑一直错误了，今天了解了Kcptun原理，才知道在客户端设置得反过来，Kcptun原理图如下：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_15.png" alt="Kcptun原理"></p>
<p>可以看到，本地向服务器发送请求后，服务器会向本地发送数据，数据本来通过服务端的Shadowsocks端口发送到本地的Shadowsocks端口，有了Kcptun之后，服务端的数据通过Shadowsocks端口再通过Kcptun端口发送到本地的Kcptun端口，然后再发送到本地的Shadowsocks端口。知道这个原理之后，我们清楚本地要先配置的是Kcptun，打开Kcptun管理工具：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_16.png" alt="Kcptun管理工具"></p>
<p>把Kcptun客户端按住放进来，右上角的路径已经填好了。本地端口自己填一个就好了，Kcp服务器地址填VPS的服务器IP，端口填Kcptun服务器上的端口，我上面是29900。其他的配置信息按照服务端的配置。</p>
<h3 id="Shadowsocks配置"><a href="#Shadowsocks配置" class="headerlink" title="Shadowsocks配置"></a>Shadowsocks配置</h3><p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_17.png" alt="Shadowsocks客户端配置"><br>这里的服务器地址写本地<code>127.0.0.1</code>，端口写刚才Kcptun自设的端口<code>10800</code>，密码是Shadowsocks服务端的密码，右下角再填个本地的端口。这个本地的端口，待会要用，数据就是从这个端口出来的。</p>
<h3 id="Chrome装Proxy-SwitchyOmega插件"><a href="#Chrome装Proxy-SwitchyOmega插件" class="headerlink" title="Chrome装Proxy SwitchyOmega插件"></a>Chrome装Proxy SwitchyOmega插件</h3><p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_18.png" alt="Proxy SwitchyOmega"></p>
<p>Chrome浏览器安装Proxy SwitchyOmega，之后打开选项：</p>
<p><img src="/2017/04/03/搭建Shadowsocks并使用/ss_19.png" alt="Proxy SwitchyOmega"></p>
<p>选个情景模式，把代理协议选为<code>SOCKS5</code>，服务器填本地<code>127.0.0.1</code>，端口就是要填刚才Shadowsocks自设的端口，我的就是10801，填完之后保存，在浏览器选中该情景模式，就可以科学上网了！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哎呀，这次搭建Shadowsocks真是几经波折，网上很多教程都写不全，拼起来看也有很多错误。不过，Kcptun加速的效果实在太显著了，youtube看1080P完全不卡的。</p>
]]></content:encoded>
      
      <comments>http://yoursite.com/2017/04/03/%E6%90%AD%E5%BB%BAShadowsocks%E5%B9%B6%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo主题和添加评论、打赏、搜索、阅读量等功能</title>
      <link>http://yoursite.com/2017/03/30/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E3%80%81%E6%89%93%E8%B5%8F%E3%80%81%E6%90%9C%E7%B4%A2%E3%80%81%E9%98%85%E8%AF%BB%E9%87%8F%E7%AD%89%E5%8A%9F%E8%83%BD/</link>
      <guid>http://yoursite.com/2017/03/30/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E3%80%81%E6%89%93%E8%B5%8F%E3%80%81%E6%90%9C%E7%B4%A2%E3%80%81%E9%98%85%E8%AF%BB%E9%87%8F%E7%AD%89%E5%8A%9F%E8%83%BD/</guid>
      <pubDate>Thu, 30 Mar 2017 15:09:34 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;以下绝大部分转载于&lt;a href=&quot;http://www.jianshu.com/p/5973c05d7100&quot; target=&quot;_blan
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以下绝大部分转载于<a href="http://www.jianshu.com/p/5973c05d7100" target="_blank" rel="external">【干货】2个小时教你hexo博客添加评论、打赏、RSS等功能</a>，原文真是满满的干货，看完学习了许多许多，受益匪浅，在这里感谢下作者，写得太好了，以下是原文加上我自己操作中的一些东西。</p>
<h2 id="更换Hexo主题"><a href="#更换Hexo主题" class="headerlink" title="更换Hexo主题"></a>更换Hexo主题</h2><p>安装Hexo默认主题是<code>landscape</code>，长这样：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_0.png" alt="landscape"></p>
<p>更换后的主题为NexT，其Github网址为：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> 。首先将NexT的主题源文件下载到本地，使用Git克隆指令如下：</p>
<pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p>下载后，复制其中名称为next的文件夹到Hexo的主题目录下，主题目录的路径为：</p>
<pre><code>Hexo根目录/themes/
</code></pre><p>在Hexo根目录下有一个以<code>_config.yml</code>命名的文件（下称<strong>站点配置文件</strong>），用Vim等文本编辑器打开，在其中找到<code>theme</code>属性，将其由<code>landscape</code>改为<code>next</code>。</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_1.png" alt="配置修改主题"><br>然后在Hexo根目录执行<strong>部署Hexo</strong>指令：</p>
<pre><code>hexo clean
hexo g
hexo d
</code></pre><p>然后就可以看到修改后的主题：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_2.png" alt="NexT"></p>
<h2 id="设置NexT的主题模式"><a href="#设置NexT的主题模式" class="headerlink" title="设置NexT的主题模式"></a>设置NexT的主题模式</h2><p>Hexo主题中，有三种不同的模式，通过切换模式，让NexT主题显示不一样的样式。在NexT根目录下有一个同样名称为<code>_config.yml</code>，为了区分hexo根目录下的<code>_config.yml</code>，将前者称为主题配置文件，在其中找到<code>scheme</code>属性，如下图所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_3.png" alt="scheme"></p>
<p>默认的是<code>Muse</code>模式，我设置的是<code>Mist</code>，在NexT的GitHub主页上展示的是这种模式，很简洁。读者可根据自己的喜好，选择其中一种模式。</p>
<h2 id="设置预览摘要"><a href="#设置预览摘要" class="headerlink" title="设置预览摘要"></a>设置预览摘要</h2><p>设置完模式后，读者们会发现，尽管首页显示的是所有文章的列表，但是每一篇文章都显示了所有内容，这样感觉看起来不舒服，这时候可以启用预览摘要模式，在主题配置文件中找到<code>auto_excerpt</code>属性，将<code>enable</code>设置为<code>true</code> ，将<code>length</code>设置为想要预览到的字数，默认是150，如下图所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_4.png" alt="auto_excerpt"></p>
<p>设置方面的修改完成之后，最好都重新clean-&gt;generate-&gt;deploy一下。</p>
<h2 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h2><p>NexT目前出到5.1.0版本，功能模块已经相当的丰富。NexT主题集成了评论系统，只需要设置相关的属性即可实现功能，其目前支持多说、Disqus、Facebook评论、Hyper评论、网页云跟帖等。这里我们使用的是另一款名为友言的评论系统，它也是NexT已经集成好的，可以直接拿来用的。打开<a href="http://www.uyan.cc" target="_blank" rel="external">友言官网</a>，注册账号，进入“后台管理”，可以看到自己的用户ID。</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_5.png" alt="用户ID"></p>
<p>打开<code>hexo根目录/themes/next/_config.yml</code>，我们称这个为“主题配置文件”，找到下面这项：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_6.png" alt="用户ID"></p>
<p>将刚才的用户ID填进去。在这里不得不感叹下NexT的精妙，可供使用者修改的地方非常多，修改添加的时候又特别方便，添加的时候只要去掉注释就好了。</p>
<p>效果如下：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_7.png" alt="评论"></p>
<h2 id="添加打赏功能"><a href="#添加打赏功能" class="headerlink" title="添加打赏功能"></a>添加打赏功能</h2><p>打赏是读者对笔者支持的最大动力，作为写博客的我来说，打赏功能如果在自己的博客中出现，那真的是求之不得呀（虽然基本不会有人来打赏）！而NexT正好集成了打赏的功能，其实现的思路是放上收款二维码，让读者扫码后支付。原作者添加了微信支付和支付宝支付，所以以此为例：</p>
<h3 id="获取微信收款二维码"><a href="#获取微信收款二维码" class="headerlink" title="获取微信收款二维码"></a>获取微信收款二维码</h3><p>微信二维码的获取途径还是比较容易的，按照<a href="http://jingyan.baidu.com/article/b907e627b641b646e6891c6b.html" target="_blank" rel="external">这个教程</a>即可实现，读者们也可以预先设置收款的金额。</p>
<h3 id="获取支付宝收款二维码"><a href="#获取支付宝收款二维码" class="headerlink" title="获取支付宝收款二维码"></a>获取支付宝收款二维码</h3><p>在支付宝首页的“收款”，截图即可得到二维码。</p>
<h3 id="添加二维码图片资源"><a href="#添加二维码图片资源" class="headerlink" title="添加二维码图片资源"></a>添加二维码图片资源</h3><p>得到二维码图片资源后，读者们可将二维码图片放到<code>NexT根目录/source/images/</code>文件夹下。</p>
<h3 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h3><p>找到主题配置文件，在其最后添加打赏的配置信息：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_8.png" alt="reward_comment"></p>
<p>部署后，效果如下：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_9.png" alt="打赏"></p>
<h2 id="设置侧边栏显示效果"><a href="#设置侧边栏显示效果" class="headerlink" title="设置侧边栏显示效果"></a>设置侧边栏显示效果</h2><p>在主题配置文件中，找到<code>sidebar</code>的<code>display</code>属性，<code>display</code>属性有四种显示模式：分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">post    // 默认显示方式</div><div class="line">always  // 一直显示</div><div class="line">hide    // 初始隐藏</div><div class="line">remove  // 移除侧边栏</div></pre></td></tr></table></figure>
<p>我设置为hide模式，如下图所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_10.png" alt="sidebar"></p>
<h2 id="添加菜单选项"><a href="#添加菜单选项" class="headerlink" title="添加菜单选项"></a>添加菜单选项</h2><p>默认情况下，菜单导航栏有首页、归档、关于三个选项，除此之外笔者还添加了分类、标签和关于。在主题配置文件中，找到<code>menu</code>属性，并去掉<code>categories</code>、<code>tags</code>、<code>about</code>的注释，如下图所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_11.png" alt="menu"></p>
<p>然后在Hexo根目录执行指令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 添加分类页面</div><div class="line">hexo new page &quot;categories&quot;</div><div class="line">// 添加标签页面</div><div class="line">hexo new page “tags”</div><div class="line">// 添加关于页面</div><div class="line">hexo new page &quot;about&quot;</div></pre></td></tr></table></figure>
<p>执行完上述指令后，在<code>Hexo根目录/source/</code>文件夹下创建三个文件夹，命名分别为：<code>categories</code>、<code>tags</code>、<code>about</code>文件夹，在这些文件夹中分别会创建一个以<code>index</code>命名的Markdown文件，对这三个Markdown文件内容进行修改，使之分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: categories</div><div class="line">date: 2017-03-12 22:06:24</div><div class="line">type: &quot;categories&quot;</div><div class="line">---</div><div class="line">---</div><div class="line">title: 标签</div><div class="line">date: 2017-03-12 17:27:16</div><div class="line">type: &quot;tags&quot;</div><div class="line">---</div><div class="line">---</div><div class="line">title: about</div><div class="line">date: 2017-03-12 22:07:26</div><div class="line">type: &quot;about&quot;</div><div class="line">---</div></pre></td></tr></table></figure>
<p>完成文件的修改，然后部署Hexo即可完成菜单选项的添加。</p>
<h2 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h2><p>完成了上述菜单选项的添加后，读者们可以看到菜单栏中还有搜索一项，搜索的功能源于第三方服务——Algolia，接下来看看配置的步骤：</p>
<h3 id="注册Algolia，创建Index"><a href="#注册Algolia，创建Index" class="headerlink" title="注册Algolia，创建Index"></a>注册Algolia，创建Index</h3><p>在Algolia官网注册一个账户，完成账户注册后，创建一个Index，如下图：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_12.png" alt="创建Index"></p>
<h3 id="安装Hexo-Algolia"><a href="#安装Hexo-Algolia" class="headerlink" title="安装Hexo Algolia"></a>安装Hexo Algolia</h3><p>在Hexo根目录执行如下指令，进行Hexo Algolia的安装：</p>
<pre><code>npm install --save hexo-algolia
</code></pre><p>执行完指令后，读者们可能会发现安装失败，或发现安装成功后实现的搜索功能可以搜索但是不可以点击搜索到的文章，这是因为5.1.0版本NexT在<code>package.json</code>文件的配置中存在错误。</p>
<p>到Hexo的根目录，在其中找到<code>package.json</code>文件，修改其中的<code>hexo-algolia</code>属性值为<code>^0.2.0</code>，本来为<code>^0.1.1</code>，如下图所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_13.png" alt="修改package.json文件"></p>
<pre><code>&quot;hexo-algolia&quot;: &quot;^0.2.0&quot;
</code></pre><p>然后再执行上述的安装指令。</p>
<h3 id="获取Key，修改站点配置"><a href="#获取Key，修改站点配置" class="headerlink" title="获取Key，修改站点配置"></a>获取Key，修改站点配置</h3><p>完成Hexo Algolia后，回到Algolia官网的Dashboard，在左侧导航栏选择API Keys一项，跳转到如下图所示的页面：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_14.png" alt="获取Key"></p>
<p>基于这个页面的Key，编辑站点配置文件，在文件内容最后添加如下图所示的信息，包括  <code>ApplicationID</code>、<code>Search-Only API Key</code>、<code>Admin API Key</code>和<code>indexName</code>，其中<code>apiKey</code>就是<code>Search-Only API Key</code>：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_15.png" alt="Algolia配置信息"></p>
<h3 id="更新Index"><a href="#更新Index" class="headerlink" title="更新Index"></a>更新Index</h3><p>配置好Key后，在Hexo根目录执行<code>hexo algolia</code>来更新Index，若出现如下图所示，则表示更新成功：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_16.png" alt="更新Index"></p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_17.png" alt="更新Index"></p>
<p>若更新失败，则返回上面安装Hexo Algolia的步骤，查看一下hexo-algolia是否安装成功，并核实一下package.json信息是否正确。</p>
<h3 id="启用配置搜索功能"><a href="#启用配置搜索功能" class="headerlink" title="启用配置搜索功能"></a>启用配置搜索功能</h3><p>修改主题配置文件，在其中找到<code>algolia_search</code>属性，将其<code>enable</code>子属性改为<code>true</code>，然后再看其<code>labels</code>子属性，修改相应的提示文本，使之更加适合自己的风格，属性配置如下图所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_18.png" alt="algolia_search"></p>
<p>经过上述的操作后，部署Hexo，便可在博客中添加搜索功能，其效果图如下：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_19.png" alt="找到搜索结果"></p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_20.png" alt="未找到搜索结果"></p>
<h2 id="添加阅读次数统计"><a href="#添加阅读次数统计" class="headerlink" title="添加阅读次数统计"></a>添加阅读次数统计</h2><p>阅读次数统计是基于第三方服务——LeanCloud实现的，步骤如下：</p>
<h3 id="创建LeanCloud账号"><a href="#创建LeanCloud账号" class="headerlink" title="创建LeanCloud账号"></a>创建LeanCloud账号</h3><p>进入<img src="https://leancloud.cn" alt="LeanCloud官网">，注册。</p>
<h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>注册并登录LeanCloud后，进入控制台，单击“创建应用”按钮进行应用的创建，输入新应用名称，选择开发版，单击“创建”按钮完成创建，如下图所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_21.png" alt="创建应用"></p>
<h3 id="创建Class"><a href="#创建Class" class="headerlink" title="创建Class"></a>创建Class</h3><p>进入到刚刚创建的应用中，选择左侧导航栏的“存储”，然后点击“创建Class”，为了与NexT形成配置关系，将Class名称填为<code>Counter</code>，并选择无限制选项，然后单击“创建Class”按钮完成Class的创建，如下图所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_22.png" alt="创建Class"></p>
<p>点击刚刚创建的Counter，其实质是一张结构表，用来记录文章的浏览量，如下图所示，这里的表可以直接对文章阅读次数进行修改，所以如果想要追求阅读次数的读者可以在表上直接进行修改。</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_23.png" alt="Counter表"></p>
<h3 id="配置Key"><a href="#配置Key" class="headerlink" title="配置Key"></a>配置Key</h3><p>在左侧导航栏的设置界面，单击“应用Key”可以看到应用的App ID和App Key。</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_24.png" alt="Key"></p>
<p>复制ID和Key，然后将其配置到主题配置文件中，在文件中找到<code>leancloud_visitors</code>属性，将<code>enable</code>设置为<code>true</code>，然后将之前复制的ID和Key粘贴到相应的属性中。</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_25.png" alt="配置ID和Key"></p>
<p>至此，阅读次数统计添加完成，其效果图如下所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_26.png" alt="添加阅读次数统计"></p>
<h2 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h2><h3 id="安装-hexo-generator-feed-插件"><a href="#安装-hexo-generator-feed-插件" class="headerlink" title="安装 hexo-generator-feed 插件"></a>安装 hexo-generator-feed 插件</h3><p>RSS需要有一个Feed链接，而这个链接需要靠<code>hexo-generator-feed</code>插件来生成，所以第一步需要添加插件，在Hexo根目录执行安装指令：</p>
<pre><code>npm install hexo-generator-feed --save
</code></pre><h3 id="配置feed信息"><a href="#配置feed信息" class="headerlink" title="配置feed信息"></a>配置feed信息</h3><p>在站点配置文件中追加如下图所示的信息：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_27.png" alt="RSS配置"></p>
<p>feed属性下的各个子属性的含义借用feed官方英文解释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type - Feed type. (atom/rss2)</div><div class="line">path - Feed path. (Default: atom.xml/rss2.xml)</div><div class="line">limit - Maximum number of posts in the feed (Use 0 or false to show all posts)</div><div class="line">hub - URL of the PubSubHubbub hubs (Leave it empty if you don&apos;t use it)</div><div class="line">content - (optional) set to &apos;true&apos; to include the contents of the entire post in the feed.</div></pre></td></tr></table></figure>
<p>如此这般，RSS功能添加完成，效果图如下：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_28.png" alt="RSS效果"></p>
<p>单击RSS按钮，跳转如下界面：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_29.png" alt="RSS跳转结果"></p>
<h2 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h2><p>希望在个人博客中加入自己的邮箱和Github，接下来了解一下社交链接如何添加：</p>
<h3 id="添加链接"><a href="#添加链接" class="headerlink" title="添加链接"></a>添加链接</h3><p>在主题配置文件中找到<code>social</code>属性，在其下方添加社交链接，其格式为：</p>
<pre><code>社交平台名称：链接
</code></pre><p>笔者添加的内容如下图所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_30.png" alt="添加社交链接"></p>
<h3 id="添加链接图标"><a href="#添加链接图标" class="headerlink" title="添加链接图标"></a>添加链接图标</h3><p>读者们可根据自己喜好，启用显示链接的图标，链接的图标全部来自于<a href="https://fortawesome.com/sets/font-awesome" target="_blank" rel="external">Font Awesome</a>，其配置方式也很简单，在主题配置文件中找到<code>social_icons</code>，修改其状态值为<code>true</code>，然后配置对应链接的图标，其格式为：</p>
<pre><code>社交平台名称: Font Awesome中的图标的名字（区分大小写）
</code></pre><p>如下图所示：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_31.png" alt="添加链接图标"></p>
<h2 id="添加友情链接功能"><a href="#添加友情链接功能" class="headerlink" title="添加友情链接功能"></a>添加友情链接功能</h2><p>这次搭建自己的Hexo博客参考了很多大牛的博客，很感谢他们，我想在自己的博客上添加他们的博客链接。接下来看一下如何实现这个功能：</p>
<p>在主题配置文件中找到<code>links</code>属性，修改<code>links_title</code>属性的值为“友情链接”（也可以是其他文案），然后添加上好友的博客名称和博客地址，其格式如下：</p>
<pre><code>博客名称: 博客链接
</code></pre><p>如下是笔者的配置信息：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_32.png" alt="links配置"></p>
<p>配置完成后部署Hexo，即可实现友情链接的效果，附图如下：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_28.png" alt="友情链接"></p>
<h2 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h2><p>编辑<strong>主题配置文件</strong>，找到字段<code>avatar</code>，值设置成头像的链接地址。<br>其中，头像的链接地址可以是：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>完整的互联网 URL</td>
<td><a href="https://balabala（就举个例子）" target="_blank" rel="external">https://balabala（就举个例子）</a></td>
</tr>
<tr>
<td>站点内的地址</td>
<td>/uploads/avatar.jpg - 需要将你的头像图片放置在 站点的 source/uploads/ （可能需要新建uploads目录）</td>
</tr>
<tr>
<td></td>
<td>/images/avatar.jpg - 需要将你的头像图片放置在 主题的 source/images/ 目录下</td>
</tr>
</tbody>
</table>
<p>头像设置示例：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_33.png" alt="头像设置"></p>
<p>设置完，部署后，就可以看到头像：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_28.png" alt="头像"></p>
<h2 id="编辑网站缩略图"><a href="#编辑网站缩略图" class="headerlink" title="编辑网站缩略图"></a>编辑网站缩略图</h2><p>在主题配置文件里，可以看到：</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_34.png" alt="缩略图配置"></p>
<p>将图标命名为<code>favicon.ico</code>，然后将ico放进Hexo/source/即可。</p>
<p><img src="/2017/03/30/hexo主题和添加评论、打赏、搜索、阅读量等功能/hexo_35.png" alt="网站缩略图"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这里感谢原作者，真的很感谢，对我很有帮助，然后自己也添加了点自己的东西。</p>
]]></content:encoded>
      
      <comments>http://yoursite.com/2017/03/30/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E3%80%81%E6%89%93%E8%B5%8F%E3%80%81%E6%90%9C%E7%B4%A2%E3%80%81%E9%98%85%E8%AF%BB%E9%87%8F%E7%AD%89%E5%8A%9F%E8%83%BD/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
